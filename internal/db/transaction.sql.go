// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    connector_id,
    charge_point_id,
    reservation_id,
    id_tag,
    meter_start,
    start_timestamp,
    created_at,
    updated_at
  ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
  RETURNING id, connector_id, charge_point_id, reservation_id, status, id_tag, reason, meter_start, meter_stop, start_timestamp, stop_timestamp, created_at, updated_at
`

type CreateTransactionParams struct {
	ConnectorID    int32         `db:"connector_id" json:"connectorID"`
	ChargePointID  int64         `db:"charge_point_id" json:"chargePointID"`
	ReservationID  sql.NullInt64 `db:"reservation_id" json:"reservationID"`
	IDTag          string        `db:"id_tag" json:"idTag"`
	MeterStart     int32         `db:"meter_start" json:"meterStart"`
	StartTimestamp time.Time     `db:"start_timestamp" json:"startTimestamp"`
	CreatedAt      time.Time     `db:"created_at" json:"createdAt"`
	UpdatedAt      time.Time     `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.ConnectorID,
		arg.ChargePointID,
		arg.ReservationID,
		arg.IDTag,
		arg.MeterStart,
		arg.StartTimestamp,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.ConnectorID,
		&i.ChargePointID,
		&i.ReservationID,
		&i.Status,
		&i.IDTag,
		&i.Reason,
		&i.MeterStart,
		&i.MeterStop,
		&i.StartTimestamp,
		&i.StopTimestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, connector_id, charge_point_id, reservation_id, status, id_tag, reason, meter_start, meter_stop, start_timestamp, stop_timestamp, created_at, updated_at FROM transactions
  WHERE id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.ConnectorID,
		&i.ChargePointID,
		&i.ReservationID,
		&i.Status,
		&i.IDTag,
		&i.Reason,
		&i.MeterStart,
		&i.MeterStop,
		&i.StartTimestamp,
		&i.StopTimestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, connector_id, charge_point_id, reservation_id, status, id_tag, reason, meter_start, meter_stop, start_timestamp, stop_timestamp, created_at, updated_at FROM transactions
  ORDER BY id
`

func (q *Queries) ListTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.ConnectorID,
			&i.ChargePointID,
			&i.ReservationID,
			&i.Status,
			&i.IDTag,
			&i.Reason,
			&i.MeterStart,
			&i.MeterStop,
			&i.StartTimestamp,
			&i.StopTimestamp,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions SET (
    status,
    reason,
    meter_stop,
    stop_timestamp,
    updated_at
  ) = ($2, $3, $4, $5, $6)
  WHERE id = $1
  RETURNING id, connector_id, charge_point_id, reservation_id, status, id_tag, reason, meter_start, meter_stop, start_timestamp, stop_timestamp, created_at, updated_at
`

type UpdateTransactionParams struct {
	ID            int64                     `db:"id" json:"id"`
	Status        TransactionStatus         `db:"status" json:"status"`
	Reason        NullTransactionStopReason `db:"reason" json:"reason"`
	MeterStop     sql.NullInt32             `db:"meter_stop" json:"meterStop"`
	StopTimestamp sql.NullTime              `db:"stop_timestamp" json:"stopTimestamp"`
	UpdatedAt     time.Time                 `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransaction,
		arg.ID,
		arg.Status,
		arg.Reason,
		arg.MeterStop,
		arg.StopTimestamp,
		arg.UpdatedAt,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.ConnectorID,
		&i.ChargePointID,
		&i.ReservationID,
		&i.Status,
		&i.IDTag,
		&i.Reason,
		&i.MeterStart,
		&i.MeterStop,
		&i.StartTimestamp,
		&i.StopTimestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
