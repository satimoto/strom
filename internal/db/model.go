// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package db

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"time"
)

type CallAction string

const (
	CallActionAuthorize                     CallAction = "Authorize"
	CallActionBootNotification              CallAction = "BootNotification"
	CallActionCancelReservation             CallAction = "CancelReservation"
	CallActionChangeAvailability            CallAction = "ChangeAvailability"
	CallActionChangeConfiguration           CallAction = "ChangeConfiguration"
	CallActionClearCache                    CallAction = "ClearCache"
	CallActionClearChargingProfile          CallAction = "ClearChargingProfile"
	CallActionDataTransfer                  CallAction = "DataTransfer"
	CallActionDiagnosticsStatusNotification CallAction = "DiagnosticsStatusNotification"
	CallActionFirmwareStatusNotification    CallAction = "FirmwareStatusNotification"
	CallActionGetCompositeSchedule          CallAction = "GetCompositeSchedule"
	CallActionGetConfiguration              CallAction = "GetConfiguration"
	CallActionGetDiagnostics                CallAction = "GetDiagnostics"
	CallActionGetLocalListVersion           CallAction = "GetLocalListVersion"
	CallActionHeartbeat                     CallAction = "Heartbeat"
	CallActionMeterValues                   CallAction = "MeterValues"
	CallActionRemoteStartTransaction        CallAction = "RemoteStartTransaction"
	CallActionRemoteStopTransaction         CallAction = "RemoteStopTransaction"
	CallActionReserveNow                    CallAction = "ReserveNow"
	CallActionReset                         CallAction = "Reset"
	CallActionSendLocalList                 CallAction = "SendLocalList"
	CallActionSetChargingProfile            CallAction = "SetChargingProfile"
	CallActionStartTransaction              CallAction = "StartTransaction"
	CallActionStatusNotification            CallAction = "StatusNotification"
	CallActionStopTransaction               CallAction = "StopTransaction"
	CallActionTriggerMessage                CallAction = "TriggerMessage"
	CallActionUnlockConnector               CallAction = "UnlockConnector"
	CallActionUpdateFirmware                CallAction = "UpdateFirmware"
)

func (e *CallAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CallAction(s)
	case string:
		*e = CallAction(s)
	default:
		return fmt.Errorf("unsupported scan type for CallAction: %T", src)
	}
	return nil
}

type NullCallAction struct {
	CallAction CallAction
	Valid      bool // Valid is true if CallAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCallAction) Scan(value interface{}) error {
	if value == nil {
		ns.CallAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CallAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCallAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CallAction), nil
}

type ChargePointErrorCode string

const (
	ChargePointErrorCodeConnectorLockFailure ChargePointErrorCode = "ConnectorLockFailure"
	ChargePointErrorCodeEVCommunicationError ChargePointErrorCode = "EVCommunicationError"
	ChargePointErrorCodeGroundFailure        ChargePointErrorCode = "GroundFailure"
	ChargePointErrorCodeHighTemperature      ChargePointErrorCode = "HighTemperature"
	ChargePointErrorCodeInternalError        ChargePointErrorCode = "InternalError"
	ChargePointErrorCodeLocalListConflict    ChargePointErrorCode = "LocalListConflict"
	ChargePointErrorCodeNoError              ChargePointErrorCode = "NoError"
	ChargePointErrorCodeOtherError           ChargePointErrorCode = "OtherError"
	ChargePointErrorCodeOverCurrentFailure   ChargePointErrorCode = "OverCurrentFailure"
	ChargePointErrorCodeOverVoltage          ChargePointErrorCode = "OverVoltage"
	ChargePointErrorCodePowerMeterFailure    ChargePointErrorCode = "PowerMeterFailure"
	ChargePointErrorCodePowerSwitchFailure   ChargePointErrorCode = "PowerSwitchFailure"
	ChargePointErrorCodeReaderFailure        ChargePointErrorCode = "ReaderFailure"
	ChargePointErrorCodeResetFailure         ChargePointErrorCode = "ResetFailure"
	ChargePointErrorCodeUnderVoltage         ChargePointErrorCode = "UnderVoltage"
	ChargePointErrorCodeWeakSignal           ChargePointErrorCode = "WeakSignal"
)

func (e *ChargePointErrorCode) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ChargePointErrorCode(s)
	case string:
		*e = ChargePointErrorCode(s)
	default:
		return fmt.Errorf("unsupported scan type for ChargePointErrorCode: %T", src)
	}
	return nil
}

type NullChargePointErrorCode struct {
	ChargePointErrorCode ChargePointErrorCode
	Valid                bool // Valid is true if ChargePointErrorCode is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChargePointErrorCode) Scan(value interface{}) error {
	if value == nil {
		ns.ChargePointErrorCode, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ChargePointErrorCode.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChargePointErrorCode) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ChargePointErrorCode), nil
}

type ChargePointStatus string

const (
	ChargePointStatusAvailable     ChargePointStatus = "Available"
	ChargePointStatusPreparing     ChargePointStatus = "Preparing"
	ChargePointStatusCharging      ChargePointStatus = "Charging"
	ChargePointStatusSuspendedEVSE ChargePointStatus = "SuspendedEVSE"
	ChargePointStatusSuspendedEV   ChargePointStatus = "SuspendedEV"
	ChargePointStatusFinishing     ChargePointStatus = "Finishing"
	ChargePointStatusReserved      ChargePointStatus = "Reserved"
	ChargePointStatusUnavailable   ChargePointStatus = "Unavailable"
	ChargePointStatusFaulted       ChargePointStatus = "Faulted"
)

func (e *ChargePointStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ChargePointStatus(s)
	case string:
		*e = ChargePointStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ChargePointStatus: %T", src)
	}
	return nil
}

type NullChargePointStatus struct {
	ChargePointStatus ChargePointStatus
	Valid             bool // Valid is true if ChargePointStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChargePointStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ChargePointStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ChargePointStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChargePointStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ChargePointStatus), nil
}

type MeterLocation string

const (
	MeterLocationBody   MeterLocation = "Body"
	MeterLocationCable  MeterLocation = "Cable"
	MeterLocationEV     MeterLocation = "EV"
	MeterLocationInlet  MeterLocation = "Inlet"
	MeterLocationOutlet MeterLocation = "Outlet"
)

func (e *MeterLocation) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MeterLocation(s)
	case string:
		*e = MeterLocation(s)
	default:
		return fmt.Errorf("unsupported scan type for MeterLocation: %T", src)
	}
	return nil
}

type NullMeterLocation struct {
	MeterLocation MeterLocation
	Valid         bool // Valid is true if MeterLocation is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMeterLocation) Scan(value interface{}) error {
	if value == nil {
		ns.MeterLocation, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MeterLocation.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMeterLocation) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MeterLocation), nil
}

type MeterMeasurand string

const (
	MeterMeasurandCurrentExport                MeterMeasurand = "Current.Export"
	MeterMeasurandCurrentImport                MeterMeasurand = "Current.Import"
	MeterMeasurandCurrentOffered               MeterMeasurand = "Current.Offered"
	MeterMeasurandEnergyActiveExportRegister   MeterMeasurand = "Energy.Active.Export.Register"
	MeterMeasurandEnergyActiveImportRegister   MeterMeasurand = "Energy.Active.Import.Register"
	MeterMeasurandEnergyReactiveExportRegister MeterMeasurand = "Energy.Reactive.Export.Register"
	MeterMeasurandEnergyReactiveImportRegister MeterMeasurand = "Energy.Reactive.Import.Register"
	MeterMeasurandEnergyActiveExportInterval   MeterMeasurand = "Energy.Active.Export.Interval"
	MeterMeasurandEnergyActiveImportInterval   MeterMeasurand = "Energy.Active.Import.Interval"
	MeterMeasurandEnergyReactiveExportInterval MeterMeasurand = "Energy.Reactive.Export.Interval"
	MeterMeasurandEnergyReactiveImportInterval MeterMeasurand = "Energy.Reactive.Import.Interval"
	MeterMeasurandFrequency                    MeterMeasurand = "Frequency"
	MeterMeasurandPowerActiveExport            MeterMeasurand = "Power.Active.Export"
	MeterMeasurandPowerActiveImport            MeterMeasurand = "Power.Active.Import"
	MeterMeasurandPowerFactor                  MeterMeasurand = "Power.Factor"
	MeterMeasurandPowerOffered                 MeterMeasurand = "Power.Offered"
	MeterMeasurandPowerReactiveExport          MeterMeasurand = "Power.Reactive.Export"
	MeterMeasurandPowerReactiveImport          MeterMeasurand = "Power.Reactive.Import"
	MeterMeasurandRPM                          MeterMeasurand = "RPM"
	MeterMeasurandSoC                          MeterMeasurand = "SoC"
	MeterMeasurandTemperature                  MeterMeasurand = "Temperature"
	MeterMeasurandVoltage                      MeterMeasurand = "Voltage"
)

func (e *MeterMeasurand) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MeterMeasurand(s)
	case string:
		*e = MeterMeasurand(s)
	default:
		return fmt.Errorf("unsupported scan type for MeterMeasurand: %T", src)
	}
	return nil
}

type NullMeterMeasurand struct {
	MeterMeasurand MeterMeasurand
	Valid          bool // Valid is true if MeterMeasurand is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMeterMeasurand) Scan(value interface{}) error {
	if value == nil {
		ns.MeterMeasurand, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MeterMeasurand.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMeterMeasurand) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MeterMeasurand), nil
}

type MeterPhase string

const (
	MeterPhaseL1   MeterPhase = "L1"
	MeterPhaseL2   MeterPhase = "L2"
	MeterPhaseL3   MeterPhase = "L3"
	MeterPhaseN    MeterPhase = "N"
	MeterPhaseL1N  MeterPhase = "L1-N"
	MeterPhaseL2N  MeterPhase = "L2-N"
	MeterPhaseL3N  MeterPhase = "L3-N"
	MeterPhaseL1L2 MeterPhase = "L1-L2"
	MeterPhaseL2L3 MeterPhase = "L2-L3"
	MeterPhaseL3L1 MeterPhase = "L3-L1"
)

func (e *MeterPhase) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MeterPhase(s)
	case string:
		*e = MeterPhase(s)
	default:
		return fmt.Errorf("unsupported scan type for MeterPhase: %T", src)
	}
	return nil
}

type NullMeterPhase struct {
	MeterPhase MeterPhase
	Valid      bool // Valid is true if MeterPhase is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMeterPhase) Scan(value interface{}) error {
	if value == nil {
		ns.MeterPhase, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MeterPhase.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMeterPhase) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MeterPhase), nil
}

type MeterReadingContext string

const (
	MeterReadingContextInterruptionBegin MeterReadingContext = "Interruption.Begin"
	MeterReadingContextInterruptionEnd   MeterReadingContext = "Interruption.End"
	MeterReadingContextOther             MeterReadingContext = "Other"
	MeterReadingContextSampleClock       MeterReadingContext = "Sample.Clock"
	MeterReadingContextSamplePeriodic    MeterReadingContext = "Sample.Periodic"
	MeterReadingContextTransactionBegin  MeterReadingContext = "Transaction.Begin"
	MeterReadingContextTransactionEnd    MeterReadingContext = "Transaction.End"
	MeterReadingContextTrigger           MeterReadingContext = "Trigger"
)

func (e *MeterReadingContext) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MeterReadingContext(s)
	case string:
		*e = MeterReadingContext(s)
	default:
		return fmt.Errorf("unsupported scan type for MeterReadingContext: %T", src)
	}
	return nil
}

type NullMeterReadingContext struct {
	MeterReadingContext MeterReadingContext
	Valid               bool // Valid is true if MeterReadingContext is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMeterReadingContext) Scan(value interface{}) error {
	if value == nil {
		ns.MeterReadingContext, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MeterReadingContext.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMeterReadingContext) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MeterReadingContext), nil
}

type MeterUnitOfMeasure string

const (
	MeterUnitOfMeasureWh         MeterUnitOfMeasure = "Wh"
	MeterUnitOfMeasureKWh        MeterUnitOfMeasure = "kWh"
	MeterUnitOfMeasureVarh       MeterUnitOfMeasure = "varh"
	MeterUnitOfMeasureKvarh      MeterUnitOfMeasure = "kvarh"
	MeterUnitOfMeasureW          MeterUnitOfMeasure = "W"
	MeterUnitOfMeasureKW         MeterUnitOfMeasure = "kW"
	MeterUnitOfMeasureVA         MeterUnitOfMeasure = "VA"
	MeterUnitOfMeasureKVA        MeterUnitOfMeasure = "kVA"
	MeterUnitOfMeasureVar        MeterUnitOfMeasure = "var"
	MeterUnitOfMeasureKvar       MeterUnitOfMeasure = "kvar"
	MeterUnitOfMeasureA          MeterUnitOfMeasure = "A"
	MeterUnitOfMeasureV          MeterUnitOfMeasure = "V"
	MeterUnitOfMeasureCelsius    MeterUnitOfMeasure = "Celsius"
	MeterUnitOfMeasureFahrenheit MeterUnitOfMeasure = "Fahrenheit"
	MeterUnitOfMeasureK          MeterUnitOfMeasure = "K"
	MeterUnitOfMeasurePercent    MeterUnitOfMeasure = "Percent"
)

func (e *MeterUnitOfMeasure) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MeterUnitOfMeasure(s)
	case string:
		*e = MeterUnitOfMeasure(s)
	default:
		return fmt.Errorf("unsupported scan type for MeterUnitOfMeasure: %T", src)
	}
	return nil
}

type NullMeterUnitOfMeasure struct {
	MeterUnitOfMeasure MeterUnitOfMeasure
	Valid              bool // Valid is true if MeterUnitOfMeasure is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMeterUnitOfMeasure) Scan(value interface{}) error {
	if value == nil {
		ns.MeterUnitOfMeasure, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MeterUnitOfMeasure.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMeterUnitOfMeasure) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MeterUnitOfMeasure), nil
}

type MeterValueFormat string

const (
	MeterValueFormatRaw        MeterValueFormat = "Raw"
	MeterValueFormatSignedData MeterValueFormat = "SignedData"
)

func (e *MeterValueFormat) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MeterValueFormat(s)
	case string:
		*e = MeterValueFormat(s)
	default:
		return fmt.Errorf("unsupported scan type for MeterValueFormat: %T", src)
	}
	return nil
}

type NullMeterValueFormat struct {
	MeterValueFormat MeterValueFormat
	Valid            bool // Valid is true if MeterValueFormat is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMeterValueFormat) Scan(value interface{}) error {
	if value == nil {
		ns.MeterValueFormat, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MeterValueFormat.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMeterValueFormat) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MeterValueFormat), nil
}

type ReservationStatus string

const (
	ReservationStatusAccepted    ReservationStatus = "Accepted"
	ReservationStatusCancelled   ReservationStatus = "Cancelled"
	ReservationStatusCompleted   ReservationStatus = "Completed"
	ReservationStatusFaulted     ReservationStatus = "Faulted"
	ReservationStatusOccupied    ReservationStatus = "Occupied"
	ReservationStatusRejected    ReservationStatus = "Rejected"
	ReservationStatusUnavailable ReservationStatus = "Unavailable"
)

func (e *ReservationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReservationStatus(s)
	case string:
		*e = ReservationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ReservationStatus: %T", src)
	}
	return nil
}

type NullReservationStatus struct {
	ReservationStatus ReservationStatus
	Valid             bool // Valid is true if ReservationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReservationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ReservationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReservationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReservationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReservationStatus), nil
}

type TransactionStatus string

const (
	TransactionStatusStarted TransactionStatus = "Started"
	TransactionStatusStopped TransactionStatus = "Stopped"
)

func (e *TransactionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionStatus(s)
	case string:
		*e = TransactionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionStatus: %T", src)
	}
	return nil
}

type NullTransactionStatus struct {
	TransactionStatus TransactionStatus
	Valid             bool // Valid is true if TransactionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionStatus), nil
}

type TransactionStopReason string

const (
	TransactionStopReasonEmergencyStop  TransactionStopReason = "EmergencyStop"
	TransactionStopReasonEVDisconnected TransactionStopReason = "EVDisconnected"
	TransactionStopReasonHardReset      TransactionStopReason = "HardReset"
	TransactionStopReasonOther          TransactionStopReason = "Other"
	TransactionStopReasonOutlet         TransactionStopReason = "Outlet"
	TransactionStopReasonPowerLoss      TransactionStopReason = "PowerLoss"
	TransactionStopReasonReboot         TransactionStopReason = "Reboot"
	TransactionStopReasonRemote         TransactionStopReason = "Remote"
	TransactionStopReasonSoftReset      TransactionStopReason = "SoftReset"
	TransactionStopReasonUnlockCommand  TransactionStopReason = "UnlockCommand"
	TransactionStopReasonDeAuthorized   TransactionStopReason = "DeAuthorized"
)

func (e *TransactionStopReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionStopReason(s)
	case string:
		*e = TransactionStopReason(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionStopReason: %T", src)
	}
	return nil
}

type NullTransactionStopReason struct {
	TransactionStopReason TransactionStopReason
	Valid                 bool // Valid is true if TransactionStopReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionStopReason) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionStopReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionStopReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionStopReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionStopReason), nil
}

type Call struct {
	ID            int64      `db:"id" json:"id"`
	ChargePointID int64      `db:"charge_point_id" json:"chargePointID"`
	ReqID         string     `db:"req_id" json:"reqID"`
	Action        CallAction `db:"action" json:"action"`
	CreatedAt     time.Time  `db:"created_at" json:"createdAt"`
}

type ChargePoint struct {
	ID                int64          `db:"id" json:"id"`
	Identity          string         `db:"identity" json:"identity"`
	Model             string         `db:"model" json:"model"`
	Vendor            string         `db:"vendor" json:"vendor"`
	SerialNumber      sql.NullString `db:"serial_number" json:"serialNumber"`
	FirmwareVerion    sql.NullString `db:"firmware_verion" json:"firmwareVerion"`
	ModemIccid        sql.NullString `db:"modem_iccid" json:"modemIccid"`
	ModemImsi         sql.NullString `db:"modem_imsi" json:"modemImsi"`
	MeterSerialNumber sql.NullString `db:"meter_serial_number" json:"meterSerialNumber"`
	MeterType         sql.NullString `db:"meter_type" json:"meterType"`
	CreatedAt         time.Time      `db:"created_at" json:"createdAt"`
	UpdatedAt         time.Time      `db:"updated_at" json:"updatedAt"`
}

type Connector struct {
	ID              int64                `db:"id" json:"id"`
	ConnectorID     int32                `db:"connector_id" json:"connectorID"`
	ChargePointID   int64                `db:"charge_point_id" json:"chargePointID"`
	ErrorCode       ChargePointErrorCode `db:"error_code" json:"errorCode"`
	Status          ChargePointStatus    `db:"status" json:"status"`
	Info            sql.NullString       `db:"info" json:"info"`
	VendorID        sql.NullString       `db:"vendor_id" json:"vendorID"`
	VendorErrorCode sql.NullString       `db:"vendor_error_code" json:"vendorErrorCode"`
	CreatedAt       time.Time            `db:"created_at" json:"createdAt"`
	UpdatedAt       time.Time            `db:"updated_at" json:"updatedAt"`
}

type MeterValue struct {
	ID              int64                  `db:"id" json:"id"`
	ConnectorID     int32                  `db:"connector_id" json:"connectorID"`
	ChargePointID   int64                  `db:"charge_point_id" json:"chargePointID"`
	TransactionID   sql.NullInt64          `db:"transaction_id" json:"transactionID"`
	Format          MeterValueFormat       `db:"format" json:"format"`
	Context         MeterReadingContext    `db:"context" json:"context"`
	Measurand       MeterMeasurand         `db:"measurand" json:"measurand"`
	Phase           NullMeterPhase         `db:"phase" json:"phase"`
	Location        MeterLocation          `db:"location" json:"location"`
	Unit            NullMeterUnitOfMeasure `db:"unit" json:"unit"`
	RawValue        sql.NullFloat64        `db:"raw_value" json:"rawValue"`
	SignedDataValue sql.NullString         `db:"signed_data_value" json:"signedDataValue"`
	Timestamp       time.Time              `db:"timestamp" json:"timestamp"`
	CreatedAt       time.Time              `db:"created_at" json:"createdAt"`
}

type Reservation struct {
	ID            int64             `db:"id" json:"id"`
	ConnectorID   int32             `db:"connector_id" json:"connectorID"`
	ChargePointID int64             `db:"charge_point_id" json:"chargePointID"`
	ReqID         string            `db:"req_id" json:"reqID"`
	ExpiryDate    time.Time         `db:"expiry_date" json:"expiryDate"`
	Status        ReservationStatus `db:"status" json:"status"`
	IDTag         string            `db:"id_tag" json:"idTag"`
	ParentIDTag   sql.NullString    `db:"parent_id_tag" json:"parentIDTag"`
	CreatedAt     time.Time         `db:"created_at" json:"createdAt"`
	UpdatedAt     time.Time         `db:"updated_at" json:"updatedAt"`
}

type Transaction struct {
	ID             int64                     `db:"id" json:"id"`
	ConnectorID    int32                     `db:"connector_id" json:"connectorID"`
	ChargePointID  int64                     `db:"charge_point_id" json:"chargePointID"`
	ReservationID  sql.NullInt64             `db:"reservation_id" json:"reservationID"`
	Status         TransactionStatus         `db:"status" json:"status"`
	IDTag          string                    `db:"id_tag" json:"idTag"`
	Reason         NullTransactionStopReason `db:"reason" json:"reason"`
	MeterStart     int32                     `db:"meter_start" json:"meterStart"`
	MeterStop      sql.NullInt32             `db:"meter_stop" json:"meterStop"`
	StartTimestamp time.Time                 `db:"start_timestamp" json:"startTimestamp"`
	StopTimestamp  sql.NullTime              `db:"stop_timestamp" json:"stopTimestamp"`
	CreatedAt      time.Time                 `db:"created_at" json:"createdAt"`
	UpdatedAt      time.Time                 `db:"updated_at" json:"updatedAt"`
}
